import time
from typing import List, Optional, Union

import pytest
from app import droneStatus, logger
from app.customTypes import Number
from serial.serialutil import SerialException

from . import socketio_client


class FakeTCP:
    """
    Context manager that replaces master mavlink functions with ones that raise SerialException
    """

    @staticmethod
    def return_serial_exception(*args, **kwargs) -> None:
        raise SerialException(
            "Test SerialException generated by tests.FakeTCP context manager."
        )

    def __enter__(self) -> None:
        if droneStatus.drone is not None:
            self.old_send = droneStatus.drone.master.mav.send
            droneStatus.drone.master.mav.send = FakeTCP.return_serial_exception

    def __exit__(self, type, value, traceback) -> None:
        if droneStatus.drone is not None:
            droneStatus.drone.master.mav.send = self.old_send


class NoDrone:
    """Context manager that sets the drone to `None` for the scope of the tests called within, then ensures the drone
    is returned to its previous state
    """

    def __enter__(self) -> None:
        if droneStatus.drone is None:
            logger.warning(
                "Calling NoDrone context manager when drone is already None."
            )
        self.oldDrone = droneStatus.drone
        droneStatus.drone = None

    def __exit__(self, type, value, traceback) -> None:
        droneStatus.drone = self.oldDrone


class ParamRefreshTimeout:
    """Context manager that replaces the mavlink recv_msg function in drone.master with a function that returns a False value
    and sets current_param_index to -1 to cause the refresh_params function to timeout with no params received from the drone
    """

    @staticmethod
    def returns_none(*args, **kwargs) -> None:
        return None

    def __enter__(self) -> None:
        if droneStatus.drone is not None:
            self.wait_for_message = droneStatus.drone.wait_for_message
            droneStatus.drone.wait_for_message = WaitForMessageReturnsNone.returns_none  # type: ignore[method-assign]
            self.old_param_index = (
                droneStatus.drone.paramsController.current_param_index
            )
            droneStatus.drone.paramsController.current_param_index = -1

    def __exit__(self, type, value, traceback) -> None:
        if droneStatus.drone is not None:
            droneStatus.drone.wait_for_message = self.wait_for_message  # type: ignore[method-assign]
            droneStatus.drone.paramsController.current_param_index = (
                self.old_param_index
            )


class WaitForMessageReturnsNone:
    @staticmethod
    def returns_none(*args, **kwargs) -> None:
        return None

    def __enter__(self) -> None:
        if droneStatus.drone is not None:
            self.wait_for_message = droneStatus.drone.wait_for_message
            droneStatus.drone.wait_for_message = WaitForMessageReturnsNone.returns_none  # type: ignore[method-assign]

    def __exit__(self, type, value, traceback) -> None:
        if droneStatus.drone is not None:
            droneStatus.drone.wait_for_message = self.wait_for_message  # type: ignore[method-assign]


def send_and_receive(endpoint: str, args: Optional[Union[dict, str]] = None) -> dict:
    """Sends a request to the socketio test client and returns the response

    Parameters
    ----------
    endpoint : str
        The endpoint to send the request to
    args : Optional[Union[dict, str]], optional
        The arguments to pass to the endpoint, by default None

    Returns
    -------
    dict
        The data received from the client
    """
    (
        socketio_client.emit(endpoint, args)
        if args is not None
        else socketio_client.emit(endpoint)
    )
    return socketio_client.get_received()[0]["args"][0]


@pytest.fixture
def gps_failure():
    """Fixture to use when you want the test being ran to simulate a GPS system failure.

    TODO: This does not work for some reason. Fix?
    """
    droneStatus.drone.logger.info("Enabling SIM_GPS_DISABLE")
    droneStatus.drone.master.param_set_send("SIM_GPS_DISABLE", 1.0, 2)
    droneStatus.drone.master.param_set_send("SIM_GPS2_DISABLE", 1.0, 2)

    yield

    droneStatus.drone.logger.info("Disabling SIM_GPS_DISABLE")
    droneStatus.drone.master.param_set_send("SIM_GPS_DISABLE", 0.0, 2)
    droneStatus.drone.master.param_set_send("SIM_GPS2_DISABLE", 0.0, 2)


def set_params(params: List[tuple[str, Number, int]]) -> None:
    """Sets multiple parameters on the drone with robust retry logic"""
    if droneStatus.drone is None:
        raise RuntimeError("No drone connected to set parameters on.")

    for param in params:
        param_name, param_value, param_type = param
        max_retries = 7
        retry_count = 0
        param_set_successfully = False

        while retry_count < max_retries and not param_set_successfully:
            try:
                # Clear any pending messages first to avoid stale responses
                droneStatus.drone.master.recv_match(
                    type="PARAM_VALUE", blocking=False, timeout=0.1
                )

                # Send parameter set command
                logger.debug(
                    f"Attempt {retry_count + 1}: Setting {param_name} to {param_value} (type: {param_type})"
                )
                droneStatus.drone.master.mav.param_set_send(
                    droneStatus.drone.master.target_system,
                    droneStatus.drone.master.target_component,
                    param_name.encode("utf-8"),
                    param_value,
                    param_type,
                )

                # Wait for ACK with exponential backoff timeout
                base_timeout = 2 + (retry_count * 0.5)  # Increase timeout with retries
                start_time = time.time()

                while time.time() - start_time < base_timeout:
                    message = droneStatus.drone.master.recv_match(
                        type="PARAM_VALUE", blocking=False, timeout=0.1
                    )

                    if message is not None:
                        # Check if it's the parameter we're looking for
                        if message.param_id == param_name:
                            # Verify the value was actually set correctly
                            received_value = message.param_value
                            if (
                                abs(received_value - param_value) < 0.001
                            ):  # Allow for floating point precision
                                logger.info(
                                    f"Successfully set {param_name} to {param_value} (confirmed: {received_value})"
                                )
                                param_set_successfully = True
                                break
                            else:
                                logger.warning(
                                    f"Parameter {param_name} was set but value mismatch: expected {param_value}, got {received_value}"
                                )
                        else:
                            # Got a different parameter response, keep waiting
                            logger.debug(
                                f"Received PARAM_VALUE for {message.param_id}, waiting for {param_name}"
                            )

                    time.sleep(0.02)  # Reduced polling interval for faster response

                if not param_set_successfully:
                    # Timeout occurred
                    retry_count += 1
                    if retry_count < max_retries:
                        backoff_delay = 0.2 * (2**retry_count)  # Exponential backoff
                        logger.warning(
                            f"Timeout setting {param_name}, retrying in {backoff_delay:.1f}s... ({retry_count}/{max_retries})"
                        )
                        time.sleep(backoff_delay)
                    else:
                        error_msg = (
                            f"Failed to set {param_name} after {max_retries} attempts"
                        )
                        raise RuntimeError(error_msg)
            except Exception as e:
                retry_count += 1
                if retry_count < max_retries:
                    backoff_delay = 0.2 * (2**retry_count)
                    logger.warning(
                        f"Error setting {param_name}: {e}, retrying in {backoff_delay:.1f}s... ({retry_count}/{max_retries})"
                    )
                    time.sleep(backoff_delay)
                else:
                    error_msg = f"Failed after {max_retries} attempts: {e}"
                    raise RuntimeError(error_msg)

        time.sleep(0.1)

    logger.info(f"Successfully set all {len(params)} parameters")
